"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _fuzzaldrinPlus = _interopRequireDefault(require("fuzzaldrin-plus"));

var _reactTinyVirtualList = _interopRequireDefault(require("react-tiny-virtual-list"));

var _layers = require("../../layers");

var _table = require("../../table");

var _OptionShapePropType = _interopRequireDefault(require("./OptionShapePropType"));

var _Option = _interopRequireDefault(require("./Option"));

/**
 * Fuzzaldrin-plus is the default filter, but you can use your own
 * as long as they follow the following signature:
 * @param options <Array[String]> - ['label', 'label2', ...]
 * @param input <String>
 */
var fuzzyFilter = function fuzzyFilter(options, input) {
  return _fuzzaldrinPlus.default.filter(options, input);
};
/**
 * This is the default item renderer of options
 * you can pass custom renderers as long as they work the same as the Option
 */


var itemRenderer = function itemRenderer(props) {
  return _react.default.createElement(_Option.default, props);
};

itemRenderer.displayName = "itemRenderer";

var OptionsList =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(OptionsList, _PureComponent);

  function OptionsList(props, context) {
    var _this;

    (0, _classCallCheck2.default)(this, OptionsList);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OptionsList).call(this, props, context));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "isSelected", function (item) {
      var selected = _this.state.selected;
      return Boolean(selected.find(function (selectedItem) {
        return selectedItem === item.value;
      }));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "search", function (options) {
      var optionsFilter = _this.props.optionsFilter;
      var searchValue = _this.state.searchValue;
      return searchValue.trim() === '' ? options // Return if no search query
      : optionsFilter(options.map(function (item) {
        return item.labelInList || item.label;
      }), searchValue).map(function (name) {
        return options.find(function (item) {
          return item.labelInList === name || item.label === name;
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getCurrentIndex", function () {
      var selected = _this.props.selected;

      var options = _this.getFilteredOptions();

      return options.findIndex(function (option) {
        return option.value === selected[selected.length - 1];
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleKeyDown", function (e) {
      if (e.keyCode === 38) {
        _this.handleArrowUp();
      }

      if (e.keyCode === 40) {
        _this.handleArrowDown();
      }

      if (e.keyCode === 13) {
        _this.handleEnter();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleArrowUp", function () {
      var onSelect = _this.props.onSelect;

      var options = _this.getFilteredOptions();

      var nextIndex = _this.getCurrentIndex() - 1;

      if (nextIndex < 0) {
        nextIndex = options.length - 1;
      }

      onSelect(options[nextIndex]);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleArrowDown", function () {
      var onSelect = _this.props.onSelect;

      var options = _this.getFilteredOptions();

      var nextIndex = _this.getCurrentIndex() + 1;

      if (nextIndex === options.length) {
        nextIndex = 0;
      }

      onSelect(options[nextIndex]);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleEnter", function () {
      var isSelected = _this.getCurrentIndex() !== -1;

      if (isSelected) {
        _this.props.close();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleChange", function (searchValue) {
      _this.setState({
        searchValue: searchValue
      });

      _this.props.onFilterChange(searchValue);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleSelect", function (item) {
      _this.props.onSelect(item);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleDeselect", function (item) {
      _this.props.onDeselect(item);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "assignSearchRef", function (ref) {
      _this.searchRef = ref;
    });
    _this.state = {
      searchValue: props.defaultSearchValue,
      selected: props.selected
    };
    return _this;
  }

  (0, _createClass2.default)(OptionsList, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var hasFilter = this.props.hasFilter;
      if (!hasFilter) return;
      /**
       * Hacky solution for broken autoFocus
       * https://github.com/segmentio/evergreen/issues/90
       */

      requestAnimationFrame(function () {
        _this2.searchRef.querySelector('input').focus();
      });
      window.addEventListener('keydown', this.handleKeyDown);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('keydown', this.handleKeyDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.selected !== this.props.selected) {
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          selected: this.props.selected
        });
      }
    }
  }, {
    key: "getFilteredOptions",
    value: function getFilteredOptions() {
      var options = this.props.options;
      return this.search(options);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props = this.props,
          originalOptions = _this$props.options,
          close = _this$props.close,
          width = _this$props.width,
          height = _this$props.height,
          onSelect = _this$props.onSelect,
          onDeselect = _this$props.onDeselect,
          onFilterChange = _this$props.onFilterChange,
          selected = _this$props.selected,
          hasFilter = _this$props.hasFilter,
          filterPlaceholder = _this$props.filterPlaceholder,
          filterIcon = _this$props.filterIcon,
          optionSize = _this$props.optionSize,
          _renderItem = _this$props.renderItem,
          optionsFilter = _this$props.optionsFilter,
          isMultiSelect = _this$props.isMultiSelect,
          defaultSearchValue = _this$props.defaultSearchValue,
          props = (0, _objectWithoutProperties2.default)(_this$props, ["options", "close", "width", "height", "onSelect", "onDeselect", "onFilterChange", "selected", "hasFilter", "filterPlaceholder", "filterIcon", "optionSize", "renderItem", "optionsFilter", "isMultiSelect", "defaultSearchValue"]);
      var options = this.search(originalOptions);
      var listHeight = height - (hasFilter ? 32 : 0);
      var currentIndex = this.getCurrentIndex();
      var scrollToIndex = currentIndex === -1 ? 0 : currentIndex;
      return _react.default.createElement(_layers.Pane, (0, _extends2.default)({
        height: height,
        width: width,
        display: "flex",
        flexDirection: "column"
      }, props), hasFilter && _react.default.createElement(_table.TableHead, null, _react.default.createElement(_table.SearchTableHeaderCell, {
        onChange: this.handleChange,
        innerRef: this.assignSearchRef,
        borderRight: null,
        height: 32,
        placeholder: filterPlaceholder,
        icon: filterIcon
      })), _react.default.createElement(_layers.Pane, {
        flex: 1
      }, _react.default.createElement(_reactTinyVirtualList.default, (0, _extends2.default)({
        height: listHeight,
        width: "100%",
        itemSize: optionSize,
        itemCount: options.length,
        overscanCount: 20,
        scrollToAlignment: "auto"
      }, scrollToIndex ? {
        scrollToIndex: scrollToIndex
      } : {}, {
        renderItem: function renderItem(_ref) {
          var index = _ref.index,
              style = _ref.style;
          var item = options[index];

          var isSelected = _this3.isSelected(item);

          return _renderItem({
            key: item.value,
            label: item.label,
            style: style,
            height: optionSize,
            onSelect: function onSelect() {
              return _this3.handleSelect(item);
            },
            onDeselect: function onDeselect() {
              return _this3.handleDeselect(item);
            },
            isSelectable: !isSelected || isMultiSelect,
            isSelected: isSelected,
            disabled: item.disabled
          });
        }
      }))));
    }
  }]);
  return OptionsList;
}(_react.PureComponent);

exports.default = OptionsList;
OptionsList.displayName = "OptionsList";
(0, _defineProperty2.default)(OptionsList, "propTypes", {
  options: _propTypes.default.arrayOf(_OptionShapePropType.default),
  close: _propTypes.default.func,
  height: _propTypes.default.number,
  width: _propTypes.default.number,

  /**
   * When true, multi select is accounted for.
   */
  isMultiSelect: _propTypes.default.bool,

  /**
   * This holds the values of the options
   */
  selected: _propTypes.default.arrayOf(_propTypes.default.string),
  onSelect: _propTypes.default.func,
  onDeselect: _propTypes.default.func,
  onFilterChange: _propTypes.default.func,
  hasFilter: _propTypes.default.bool,
  optionSize: _propTypes.default.number,
  renderItem: _propTypes.default.func,
  filterPlaceholder: _propTypes.default.string,
  filterIcon: _propTypes.default.string,
  optionsFilter: _propTypes.default.func,
  defaultSearchValue: _propTypes.default.string
});
(0, _defineProperty2.default)(OptionsList, "defaultProps", {
  options: [],

  /**
   * Including border bottom
   * For some reason passing height to TableRow doesn't work
   * TODO: fix hacky solution
   */
  optionSize: 33,
  onSelect: function onSelect() {},
  onDeselect: function onDeselect() {},
  onFilterChange: function onFilterChange() {},
  selected: [],
  renderItem: itemRenderer,
  optionsFilter: fuzzyFilter,
  filterPlaceholder: 'Filter...',
  filterIcon: 'search',
  defaultSearchValue: ''
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZWxlY3QtbWVudS9zcmMvT3B0aW9uc0xpc3QuanMiXSwibmFtZXMiOlsiZnV6enlGaWx0ZXIiLCJvcHRpb25zIiwiaW5wdXQiLCJmdXp6YWxkcmluIiwiZmlsdGVyIiwiaXRlbVJlbmRlcmVyIiwicHJvcHMiLCJPcHRpb25zTGlzdCIsImNvbnRleHQiLCJpdGVtIiwic2VsZWN0ZWQiLCJzdGF0ZSIsIkJvb2xlYW4iLCJmaW5kIiwic2VsZWN0ZWRJdGVtIiwidmFsdWUiLCJvcHRpb25zRmlsdGVyIiwic2VhcmNoVmFsdWUiLCJ0cmltIiwibWFwIiwibGFiZWxJbkxpc3QiLCJsYWJlbCIsIm5hbWUiLCJnZXRGaWx0ZXJlZE9wdGlvbnMiLCJmaW5kSW5kZXgiLCJvcHRpb24iLCJsZW5ndGgiLCJlIiwia2V5Q29kZSIsImhhbmRsZUFycm93VXAiLCJoYW5kbGVBcnJvd0Rvd24iLCJoYW5kbGVFbnRlciIsIm9uU2VsZWN0IiwibmV4dEluZGV4IiwiZ2V0Q3VycmVudEluZGV4IiwiaXNTZWxlY3RlZCIsImNsb3NlIiwic2V0U3RhdGUiLCJvbkZpbHRlckNoYW5nZSIsIm9uRGVzZWxlY3QiLCJyZWYiLCJzZWFyY2hSZWYiLCJkZWZhdWx0U2VhcmNoVmFsdWUiLCJoYXNGaWx0ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJxdWVyeVNlbGVjdG9yIiwiZm9jdXMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlS2V5RG93biIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwcmV2UHJvcHMiLCJzZWFyY2giLCJvcmlnaW5hbE9wdGlvbnMiLCJ3aWR0aCIsImhlaWdodCIsImZpbHRlclBsYWNlaG9sZGVyIiwiZmlsdGVySWNvbiIsIm9wdGlvblNpemUiLCJyZW5kZXJJdGVtIiwiaXNNdWx0aVNlbGVjdCIsImxpc3RIZWlnaHQiLCJjdXJyZW50SW5kZXgiLCJzY3JvbGxUb0luZGV4IiwiaGFuZGxlQ2hhbmdlIiwiYXNzaWduU2VhcmNoUmVmIiwiaW5kZXgiLCJzdHlsZSIsImtleSIsImhhbmRsZVNlbGVjdCIsImhhbmRsZURlc2VsZWN0IiwiaXNTZWxlY3RhYmxlIiwiZGlzYWJsZWQiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiYXJyYXlPZiIsIk9wdGlvblNoYXBlUHJvcFR5cGUiLCJmdW5jIiwibnVtYmVyIiwiYm9vbCIsInN0cmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7O0FBTUEsSUFBTUEsV0FBVyxHQUFHLFNBQWRBLFdBQWMsQ0FBQ0MsT0FBRCxFQUFVQyxLQUFWO0FBQUEsU0FBb0JDLHdCQUFXQyxNQUFYLENBQWtCSCxPQUFsQixFQUEyQkMsS0FBM0IsQ0FBcEI7QUFBQSxDQUFwQjtBQUVBOzs7Ozs7QUFJQSxJQUFNRyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFBQyxLQUFLO0FBQUEsU0FBSSw2QkFBQyxlQUFELEVBQVlBLEtBQVosQ0FBSjtBQUFBLENBQTFCOztBQUFNRCxZOztJQUVlRSxXOzs7OztBQStDbkIsdUJBQVlELEtBQVosRUFBbUJFLE9BQW5CLEVBQTRCO0FBQUE7O0FBQUE7QUFDMUIsaUhBQU1GLEtBQU4sRUFBYUUsT0FBYjtBQUQwQixtSUFvQ2YsVUFBQUMsSUFBSSxFQUFJO0FBQUEsVUFDWEMsUUFEVyxHQUNFLE1BQUtDLEtBRFAsQ0FDWEQsUUFEVztBQUduQixhQUFPRSxPQUFPLENBQUNGLFFBQVEsQ0FBQ0csSUFBVCxDQUFjLFVBQUFDLFlBQVk7QUFBQSxlQUFJQSxZQUFZLEtBQUtMLElBQUksQ0FBQ00sS0FBMUI7QUFBQSxPQUExQixDQUFELENBQWQ7QUFDRCxLQXhDMkI7QUFBQSwrSEEwQ25CLFVBQUFkLE9BQU8sRUFBSTtBQUFBLFVBQ1ZlLGFBRFUsR0FDUSxNQUFLVixLQURiLENBQ1ZVLGFBRFU7QUFBQSxVQUVWQyxXQUZVLEdBRU0sTUFBS04s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aUIsRUFBRWtCLG1CQUFVTSxNQXJCWjtBQXNCakJ2QixFQUFBQSxVQUFVLEVBQUVpQixtQkFBVU0sTUF0Qkw7QUF1QmpCaEUsRUFBQUEsYUFBYSxFQUFFMEQsbUJBQVVHLElBdkJSO0FBd0JqQm5DLEVBQUFBLGtCQUFrQixFQUFFZ0MsbUJBQVVNO0FBeEJiLEM7OEJBREF6RSxXLGtCQTRCRztBQUNwQk4sRUFBQUEsT0FBTyxFQUFFLEVBRFc7O0FBRXBCOzs7OztBQUtBeUQsRUFBQUEsVUFBVSxFQUFFLEVBUFE7QUFRcEIxQixFQUFBQSxRQUFRLEVBQUUsb0JBQU0sQ0FBRSxDQVJFO0FBU3BCTyxFQUFBQSxVQUFVLEVBQUUsc0JBQU0sQ0FBRSxDQVRBO0FBVXBCRCxFQUFBQSxjQUFjLEVBQUUsMEJBQU0sQ0FBRSxDQVZKO0FBV3BCNUIsRUFBQUEsUUFBUSxFQUFFLEVBWFU7QUFZcEJpRCxFQUFBQSxVQUFVLEVBQUV0RCxZQVpRO0FBYXBCVyxFQUFBQSxhQUFhLEVBQUVoQixXQWJLO0FBY3BCd0QsRUFBQUEsaUJBQWlCLEVBQUUsV0FkQztBQWVwQkMsRUFBQUEsVUFBVSxFQUFFLFFBZlE7QUFnQnBCZixFQUFBQSxrQkFBa0IsRUFBRTtBQWhCQSxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBmdXp6YWxkcmluIGZyb20gJ2Z1enphbGRyaW4tcGx1cydcbmltcG9ydCBWaXJ0dWFsTGlzdCBmcm9tICdyZWFjdC10aW55LXZpcnR1YWwtbGlzdCdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgeyBUYWJsZUhlYWQsIFNlYXJjaFRhYmxlSGVhZGVyQ2VsbCB9IGZyb20gJy4uLy4uL3RhYmxlJ1xuaW1wb3J0IE9wdGlvblNoYXBlUHJvcFR5cGUgZnJvbSAnLi9PcHRpb25TaGFwZVByb3BUeXBlJ1xuaW1wb3J0IE9wdGlvbiBmcm9tICcuL09wdGlvbidcblxuLyoqXG4gKiBGdXp6YWxkcmluLXBsdXMgaXMgdGhlIGRlZmF1bHQgZmlsdGVyLCBidXQgeW91IGNhbiB1c2UgeW91ciBvd25cbiAqIGFzIGxvbmcgYXMgdGhleSBmb2xsb3cgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKiBAcGFyYW0gb3B0aW9ucyA8QXJyYXlbU3RyaW5nXT4gLSBbJ2xhYmVsJywgJ2xhYmVsMicsIC4uLl1cbiAqIEBwYXJhbSBpbnB1dCA8U3RyaW5nPlxuICovXG5jb25zdCBmdXp6eUZpbHRlciA9IChvcHRpb25zLCBpbnB1dCkgPT4gZnV6emFsZHJpbi5maWx0ZXIob3B0aW9ucywgaW5wdXQpXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZGVmYXVsdCBpdGVtIHJlbmRlcmVyIG9mIG9wdGlvbnNcbiAqIHlvdSBjYW4gcGFzcyBjdXN0b20gcmVuZGVyZXJzIGFzIGxvbmcgYXMgdGhleSB3b3JrIHRoZSBzYW1lIGFzIHRoZSBPcHRpb25cbiAqL1xuY29uc3QgaXRlbVJlbmRlcmVyID0gcHJvcHMgPT4gPE9wdGlvbiB7Li4ucHJvcHN9IC8+XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbnNMaXN0IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgb3B0aW9uczogUHJvcFR5cGVzLmFycmF5T2YoT3B0aW9uU2hhcGVQcm9wVHlwZSksXG4gICAgY2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgbXVsdGkgc2VsZWN0IGlzIGFjY291bnRlZCBmb3IuXG4gICAgICovXG4gICAgaXNNdWx0aVNlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhvbGRzIHRoZSB2YWx1ZXMgb2YgdGhlIG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZWxlY3RlZDogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVzZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRmlsdGVyQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBoYXNGaWx0ZXI6IFByb3BUeXBlcy5ib29sLFxuICAgIG9wdGlvblNpemU6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmVuZGVySXRlbTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZmlsdGVyUGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmlsdGVySWNvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvcHRpb25zRmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBkZWZhdWx0U2VhcmNoVmFsdWU6IFByb3BUeXBlcy5zdHJpbmdcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgb3B0aW9uczogW10sXG4gICAgLyoqXG4gICAgICogSW5jbHVkaW5nIGJvcmRlciBib3R0b21cbiAgICAgKiBGb3Igc29tZSByZWFzb24gcGFzc2luZyBoZWlnaHQgdG8gVGFibGVSb3cgZG9lc24ndCB3b3JrXG4gICAgICogVE9ETzogZml4IGhhY2t5IHNvbHV0aW9uXG4gICAgICovXG4gICAgb3B0aW9uU2l6ZTogMzMsXG4gICAgb25TZWxlY3Q6ICgpID0+IHt9LFxuICAgIG9uRGVzZWxlY3Q6ICgpID0+IHt9LFxuICAgIG9uRmlsdGVyQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICBzZWxlY3RlZDogW10sXG4gICAgcmVuZGVySXRlbTogaXRlbVJlbmRlcmVyLFxuICAgIG9wdGlvbnNGaWx0ZXI6IGZ1enp5RmlsdGVyLFxuICAgIGZpbHRlclBsYWNlaG9sZGVyOiAnRmlsdGVyLi4uJyxcbiAgICBmaWx0ZXJJY29uOiAnc2VhcmNoJyxcbiAgICBkZWZhdWx0U2VhcmNoVmFsdWU6ICcnXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHNlYXJjaFZhbHVlOiBwcm9wcy5kZWZhdWx0U2VhcmNoVmFsdWUsXG4gICAgICBzZWxlY3RlZDogcHJvcHMuc2VsZWN0ZWRcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGhhc0ZpbHRlciB9ID0gdGhpcy5wcm9wc1xuICAgIGlmICghaGFzRmlsdGVyKSByZXR1cm5cbiAgICAvKipcbiAgICAgKiBIYWNreSBzb2x1dGlvbiBmb3IgYnJva2VuIGF1dG9Gb2N1c1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWdtZW50aW8vZXZlcmdyZWVuL2lzc3Vlcy85MFxuICAgICAqL1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnNlYXJjaFJlZi5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmZvY3VzKClcbiAgICB9KVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bilcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAocHJldlByb3BzLnNlbGVjdGVkICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGlkLXVwZGF0ZS1zZXQtc3RhdGVcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3RlZDogdGhpcy5wcm9wcy5zZWxlY3RlZFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpc1NlbGVjdGVkID0gaXRlbSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3RlZCB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgcmV0dXJuIEJvb2xlYW4oc2VsZWN0ZWQuZmluZChzZWxlY3RlZEl0ZW0gPT4gc2VsZWN0ZWRJdGVtID09PSBpdGVtLnZhbHVlKSlcbiAgfVxuXG4gIHNlYXJjaCA9IG9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHsgb3B0aW9uc0ZpbHRlciB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgc2VhcmNoVmFsdWUgfSA9IHRoaXMuc3RhdGVcblxuICAgIHJldHVybiBzZWFyY2hWYWx1ZS50cmltKCkgPT09ICcnXG4gICAgICA/IG9wdGlvbnMgLy8gUmV0dXJuIGlmIG5vIHNlYXJjaCBxdWVyeVxuICAgICAgOiBvcHRpb25zRmlsdGVyKFxuICAgICAgICAgIG9wdGlvbnMubWFwKGl0ZW0gPT4gaXRlbS5sYWJlbEluTGlzdCB8fCBpdGVtLmxhYmVsKSxcbiAgICAgICAgICBzZWFyY2hWYWx1ZVxuICAgICAgICApLm1hcChuYW1lID0+XG4gICAgICAgICAgb3B0aW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5sYWJlbEluTGlzdCA9PT0gbmFtZSB8fCBpdGVtLmxhYmVsID09PSBuYW1lKVxuICAgICAgICApXG4gIH1cblxuICBnZXRDdXJyZW50SW5kZXggPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3RlZCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldEZpbHRlcmVkT3B0aW9ucygpXG5cbiAgICByZXR1cm4gb3B0aW9ucy5maW5kSW5kZXgoXG4gICAgICBvcHRpb24gPT4gb3B0aW9uLnZhbHVlID09PSBzZWxlY3RlZFtzZWxlY3RlZC5sZW5ndGggLSAxXVxuICAgIClcbiAgfVxuXG4gIGdldEZpbHRlcmVkT3B0aW9ucygpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiB0aGlzLnNlYXJjaChvcHRpb25zKVxuICB9XG5cbiAgaGFuZGxlS2V5RG93biA9IGUgPT4ge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDM4KSB7XG4gICAgICB0aGlzLmhhbmRsZUFycm93VXAoKVxuICAgIH1cblxuICAgIGlmIChlLmtleUNvZGUgPT09IDQwKSB7XG4gICAgICB0aGlzLmhhbmRsZUFycm93RG93bigpXG4gICAgfVxuXG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMuaGFuZGxlRW50ZXIoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUFycm93VXAgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBvblNlbGVjdCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldEZpbHRlcmVkT3B0aW9ucygpXG5cbiAgICBsZXQgbmV4dEluZGV4ID0gdGhpcy5nZXRDdXJyZW50SW5kZXgoKSAtIDFcblxuICAgIGlmIChuZXh0SW5kZXggPCAwKSB7XG4gICAgICBuZXh0SW5kZXggPSBvcHRpb25zLmxlbmd0aCAtIDFcbiAgICB9XG5cbiAgICBvblNlbGVjdChvcHRpb25zW25leHRJbmRleF0pXG4gIH1cblxuICBoYW5kbGVBcnJvd0Rvd24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBvblNlbGVjdCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldEZpbHRlcmVkT3B0aW9ucygpXG5cbiAgICBsZXQgbmV4dEluZGV4ID0gdGhpcy5nZXRDdXJyZW50SW5kZXgoKSArIDFcblxuICAgIGlmIChuZXh0SW5kZXggPT09IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBuZXh0SW5kZXggPSAwXG4gICAgfVxuXG4gICAgb25TZWxlY3Qob3B0aW9uc1tuZXh0SW5kZXhdKVxuICB9XG5cbiAgaGFuZGxlRW50ZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IHRoaXMuZ2V0Q3VycmVudEluZGV4KCkgIT09IC0xXG5cbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wcm9wcy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2hhbmdlID0gc2VhcmNoVmFsdWUgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2VhcmNoVmFsdWVcbiAgICB9KVxuICAgIHRoaXMucHJvcHMub25GaWx0ZXJDaGFuZ2Uoc2VhcmNoVmFsdWUpXG4gIH1cblxuICBoYW5kbGVTZWxlY3QgPSBpdGVtID0+IHtcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KGl0ZW0pXG4gIH1cblxuICBoYW5kbGVEZXNlbGVjdCA9IGl0ZW0gPT4ge1xuICAgIHRoaXMucHJvcHMub25EZXNlbGVjdChpdGVtKVxuICB9XG5cbiAgYXNzaWduU2VhcmNoUmVmID0gcmVmID0+IHtcbiAgICB0aGlzLnNlYXJjaFJlZiA9IHJlZlxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wdGlvbnM6IG9yaWdpbmFsT3B0aW9ucyxcbiAgICAgIGNsb3NlLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBvblNlbGVjdCxcbiAgICAgIG9uRGVzZWxlY3QsXG4gICAgICBvbkZpbHRlckNoYW5nZSxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgaGFzRmlsdGVyLFxuICAgICAgZmlsdGVyUGxhY2Vob2xkZXIsXG4gICAgICBmaWx0ZXJJY29uLFxuICAgICAgb3B0aW9uU2l6ZSxcbiAgICAgIHJlbmRlckl0ZW0sXG4gICAgICBvcHRpb25zRmlsdGVyLFxuICAgICAgaXNNdWx0aVNlbGVjdCxcbiAgICAgIGRlZmF1bHRTZWFyY2hWYWx1ZSxcbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5zZWFyY2gob3JpZ2luYWxPcHRpb25zKVxuICAgIGNvbnN0IGxpc3RIZWlnaHQgPSBoZWlnaHQgLSAoaGFzRmlsdGVyID8gMzIgOiAwKVxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuZ2V0Q3VycmVudEluZGV4KClcbiAgICBjb25zdCBzY3JvbGxUb0luZGV4ID0gY3VycmVudEluZGV4ID09PSAtMSA/IDAgOiBjdXJyZW50SW5kZXhcblxuICAgIHJldHVybiAoXG4gICAgICA8UGFuZVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgIGZsZXhEaXJlY3Rpb249XCJjb2x1bW5cIlxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICA+XG4gICAgICAgIHtoYXNGaWx0ZXIgJiYgKFxuICAgICAgICAgIDxUYWJsZUhlYWQ+XG4gICAgICAgICAgICA8U2VhcmNoVGFibGVIZWFkZXJDZWxsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgICAgaW5uZXJSZWY9e3RoaXMuYXNzaWduU2VhcmNoUmVmfVxuICAgICAgICAgICAgICBib3JkZXJSaWdodD17bnVsbH1cbiAgICAgICAgICAgICAgaGVpZ2h0PXszMn1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2ZpbHRlclBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICBpY29uPXtmaWx0ZXJJY29ufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L1RhYmxlSGVhZD5cbiAgICAgICAgKX1cbiAgICAgICAgPFBhbmUgZmxleD17MX0+XG4gICAgICAgICAgPFZpcnR1YWxMaXN0XG4gICAgICAgICAgICBoZWlnaHQ9e2xpc3RIZWlnaHR9XG4gICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgaXRlbVNpemU9e29wdGlvblNpemV9XG4gICAgICAgICAgICBpdGVtQ291bnQ9e29wdGlvbnMubGVuZ3RofVxuICAgICAgICAgICAgb3ZlcnNjYW5Db3VudD17MjB9XG4gICAgICAgICAgICBzY3JvbGxUb0FsaWdubWVudD1cImF1dG9cIlxuICAgICAgICAgICAgey4uLihzY3JvbGxUb0luZGV4XG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9JbmRleFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiB7fSl9XG4gICAgICAgICAgICByZW5kZXJJdGVtPXsoeyBpbmRleCwgc3R5bGUgfSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpdGVtID0gb3B0aW9uc1tpbmRleF1cbiAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHRoaXMuaXNTZWxlY3RlZChpdGVtKVxuICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySXRlbSh7XG4gICAgICAgICAgICAgICAga2V5OiBpdGVtLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsLFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9uU2l6ZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogKCkgPT4gdGhpcy5oYW5kbGVTZWxlY3QoaXRlbSksXG4gICAgICAgICAgICAgICAgb25EZXNlbGVjdDogKCkgPT4gdGhpcy5oYW5kbGVEZXNlbGVjdChpdGVtKSxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGFibGU6ICFpc1NlbGVjdGVkIHx8IGlzTXVsdGlTZWxlY3QsXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogaXRlbS5kaXNhYmxlZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L1BhbmU+XG4gICAgICA8L1BhbmU+XG4gICAgKVxuICB9XG59XG4iXX0=